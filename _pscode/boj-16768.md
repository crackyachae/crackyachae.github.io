---
layout  : article
title   : BOJ_16768
summary : 
date    : 2022-04-09 11:08:59 +0900
updated : 2022-04-10 02:34:51 +0900
tag     : ps-js draft
toc     : true
public  : true
parent  : [[BOJ-Index]]
latex   : false
---
* TOC
{:toc}

> 이 글은 백준 온라인 저지의 [16768번](https://www.acmicpc.net/problem/16768) 문제를 풀이한 것을 모아놓은 글입니다.
>
> 일종의 연습 기록이며 제가 정답을 받은 코드와 참고할만한 다른 코드를 같이 기록합니다. 필요한 경우 코드에 대한 해설을 기록합니다만 코드는 통과했어도 해설은 틀릴 수 있기 때문에 가볍게 참고해주시길 부탁드립니다. 피드백은 편하신 방법으로 자유롭게 주시면 감사하겠습니다.

## 2022.04.09 (JS)

| 메모리    | 시간   | 코드 길이 |
| --------- | -----  | --------- |
| 14844 KB  | 340 ms | 2077 B    |

| 단계      | 시작 시각 | 끝난 시각 | 걸린 시간 |
| --------- | --------- | --------- | --------- |
| 문제 이해 | 11:11:34  | 11:15:32  |           |
| 풀이 생각 | 11:15:36  | 11:22:59  |           |
| 코딩      | 11:23:07  | 12:10:24  |           |

```js
const fs = require("fs");
const input = fs.readFileSync('/dev/stdin').toString().trim().split("\n");

function dfs(x, y, n) {
    const visited = Array(N)
        .fill()
        .map((i) => Array(10).fill(false));
    visited[y][x] = true;

    const stack = [[x, y]];
    const chunk = [[x, y]];
    const dx = [1, 0, -1, 0];
    const dy = [0, -1, 0, 1];

    while (stack.length) {
        const [x, y] = stack.pop();
        for (let i = 0; i < 4; i += 1) {
            const nx = x + dx[i];
            const ny = y + dy[i];

            if (0 <= nx && nx < 10 && 0 <= ny && ny < N && muyo[ny][nx] === n && !visited[ny][nx]) {
                visited[ny][nx] = true;
                stack.push([nx, ny]);
                chunk.push([nx, ny]);
            }
        }
    }

    return chunk;
}

function pop(chunk) {
    chunk.forEach((coord) => {
        const [x, y] = coord;
        muyo[y][x] = "0";
    });
}

function fall() {
    for (let i = 0; i < 10; i += 1) {
        const col = [];
        for (let j = 0; j < N; j += 1) {
            col.push(muyo[j][i]);
        }
        const left = col.filter((elem) => elem !== "0");
        const newCol = Array(N - left.length).fill("0");
        newCol.push(...left);
        for (let j = 0; j < N; j += 1) {
            muyo[j][i] = newCol[j];
        }
    }
}

function main() {
    let isChanged = true;
    while (isChanged) {
        isChanged = false;
        for (let j = 0; j < N; j += 1) {
            for (let i = 0; i < 10; i += 1) {
                if (muyo[j][i] !== "0") {
                    const chunk = dfs(i, j, muyo[j][i]);
                    if (chunk.length >= K) {
                        pop(chunk);
                        isChanged = true;
                    }
                }
            }
        }
        fall();
    }
    console.log(muyo.map((line) => line.join("")).join("\n"));
}

const [NK, ...lines] = input;
const [N, K] = NK.split(" ").map((n) => parseInt(n));
const muyo = lines.map((line) => line.split("")); // cell is char

main();
```

### 아이디어 & 풀이

> 임시 작성

* cell들을 순회하면서
    * 0이 아닌 원소는 dfs로 진입
    * 순회하면서 출발점과 같으면 좌표를 stack에 push, chunk에도 push
    * 더 push할 게 없을 때 chunk의 length를 세서 K 이상이면
    * 해당 좌표를 순회하면서 0으로 바꿈
    * 반복
* 세로를 순회하면서 원소를 다 모은 뒤 0을 필터링하고 K개가 되도록 원소를 다시 채운 뒤 열을 교체

### 피드백

* 함수 매개변수 수정헀을 때 정확히 확인하고 제대로 전달하자.
* `push`의 반환값은 `push` 이후 배열의 원소의 개수라는 것을 기억하자. 반환 값이 변경된 배열이 아닌 메소드들을 주의하기.
