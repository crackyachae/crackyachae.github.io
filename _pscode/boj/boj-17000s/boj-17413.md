---
layout  : article
title   : BOJ_17413 단어 뒤집기 2
summary : 
date    : 2021-08-12 12:03:41 +0900
updated : 2023-02-19 22:45:24 +0900
tag     : ps-python ps-js
toc     : true
public  : true
parent  : [[/boj/boj-17000s]]
latex   : false
---
* TOC
{:toc}

> 이 글은 백준 온라인 저지의 [17413번](https://www.acmicpc.net/problem/17413) 문제를 파이썬(Python)으로 풀이한 것을 모아놓은 글입니다.
>
> 일종의 연습 기록이며 제가 정답을 받은 코드와 참고할만한 다른 코드를 같이 기록합니다. 필요한 경우 코드에 대한 해설을 기록합니다만 코드는 통과했어도 해설은 틀릴 수 있기 때문에 가볍게 참고해주시길 부탁드립니다. 피드백은 편하신 방법으로 자유롭게 주시면 감사하겠습니다.

## 2021.08.12 (Python)

| 메모리    | 시간  | 코드 길이 |
| --------- | ----- | --------- |
| 29452 KB  | 84 ms | 224 B     |

| 단계      | 시작 시각 | 끝난 시각 | 걸린 시간 |
| --------- | --------- | --------- | --------- |
| 문제 이해 | 12:03:53  | 12:06:12  |           |
| 풀이 생각 | 12:06:14  | 12:14:27  |           |
| 코딩      | 12:14:37  | 12:26:58  |           |

```python
S = input().replace("<", ">").split(">")
for i, s in enumerate(S):
    # 빈 문자열이면
    if s == "":
        # 아무것도 출력하지 않고 넘어간다.
        continue
    # 홀수 번째이면
    if i % 2:
        # 문자열 전후로 태그 기호를 붙여 출력한다.
        print(f"<{s}>", end="")
    # 짝수 번째이면
    else:
        # 문자열을 공백 단위로 뒤집은 뒤 출력한다.
        print(" ".join(w[::-1] for w in s.split()), end="")
print()
```

### 아이디어 & 풀이

입력받은 문자열을 태그 단위로 구분한 뒤 태그가 아닌 부분만 공백 단위로 뒤집어 출력해야 한다.

태그는 `<`와 `>`를 기준으로 `split()` 하면 구분할 수 있다.

* 두 가지의 구분자를 쓸 수 없기 때문에 `<`나 `>`중 하나로 통일시킨 뒤 해당 기호를 구분자로 사용한다.
    * 통일시킬 때는 `replace`를 이용
* 두 구분자가 연달아서 있을 때도 그사이의 `""`이 원소로 생기기 때문에 위처럼 구분하면 홀수 번째 원소들이 태그 '안'에 들어 있는 문자열이 된다.
    * e.g.1,  `<open>tag<close>`를 구분한 결과는 `["", "open", "tag", "close", ""]`
    * e.g.2,  `<int><max>2147483647<long long><max>9223372036854775807`를 구분한 결과는 `["", "int", "", "max", "2147483647", "long long", "", "max", "9223372036854775807"]`

위의 방법으로 생성한 리스트 `S`의 원소를 알맞게 출력한다.

* 빈 문자열이면 아무것도 출력하지 않고 넘어간다.
* 홀수 번째이면 문자열 전후로 태그 기호를 붙여 출력한다.
* 짝수 번째이면 문자열을 공백 단위로 뒤집은 뒤 출력한다.

## 2023.02.19 (JS)

| 메모리    | 시간  | 코드 길이 |
| --------- | ----- | --------- |
| 13516 KB  | 184 ms | 519 B     |

| 단계      | 시작 시각 | 끝난 시각 | 걸린 시간 |
| --------- | --------- | --------- | --------- |
| 문제 이해 | 19:08:57 | 19:09:19 | |
| 풀이 생각 | 19:09:22 | 19:10:10 | |
| 코딩 1    | 19:10:25 | 19:23:39 | |
| 코딩 2    | 19:39:14 | 19:52:22 | |
| 코딩 3    | 22:22:29 | 22:33:24 | |

```js
const fs = require("fs");
const input = fs.readFileSync('/dev/stdin').toString().trim();

function main() {
    const chunks = input.split("<").map((chunk) => chunk.split(">"));
    const reversedChunks = chunks.map((chunk) => {
        const word = chunk[chunk.length - 1]
            .split(" ")
            .map((word) => [...word].reverse().join(""))
            .join(" ");

        return `${chunk.length === 2 ? chunk[0] + ">" : ""}${word}`;
    });

    return reversedChunks.join("<");
}

console.log(main());
```

### 피드백

* 태그 기호가 두 개라 (`<`, `>`) 이차원 배열을 사용하면서 대치 처리를 번거롭게 했는데 위의 풀이처럼 태그 기호를 하나로 통일시키면 훨씬 간단하게 할 수 있었을 것 같다.
* 정규 표현식을 사용하면 좋을 것 같았는데 고민을 조금 더 해볼 걸 그랬다.

## 참고 답안

```js
const fs = require("fs");
const input = fs.readFileSync('/dev/stdin').toString().trim();

console.log(input.replace(/<[a-z0-9 ]+>|[a-z0-9]+/g, (match) => {
    if (match.startsWith('<')) {
        return match;
    }
    return [...match].reverse().join('');
}));
```

### 아이디어 & 풀이

* 정규 표현식을 사용해서 `<tag (공백 포함)>` 혹은 `word`(공백 미포함) 꼴에 일치하는 문자열을 찾아서 주어진 조건에 맞게 replace 한다.
    * `g` 사용해서 일치하는 모든 문자열에 대해서 replace 한다.
* 태그인 경우 (`<`로 시작) 일치하는 부분을 그대로 반환한다.
* 단어인 경우 글자를 뒤집어서 반환한다.
