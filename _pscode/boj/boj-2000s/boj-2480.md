---
layout  : article
title   : BOJ_2480 주사위 세개
summary : 
date    : 2021-03-25 22:01:03 +0900
updated : 2021-03-25 23:25:14 +0900
tag     : ps-python
toc     : true
public  : true
parent  : [[/boj/boj-2000s]]
latex   : false
---
* TOC
{:toc}

> 이 글은 백준 온라인 저지의 [2480번](https://www.acmicpc.net/problem/2480) 문제를 파이썬(Python)으로 풀이한 것을 모아놓은 글입니다.
>
> 일종의 연습 기록이며 제가 정답을 받은 코드와 참고할만한 다른 코드를 같이 기록합니다. 필요한 경우 코드에 대한 해설을 기록합니다만 코드는 통과했어도 해설은 틀릴 수 있기 때문에 가볍게 참고해주시길 부탁드립니다. 피드백은 편하신 방법으로 자유롭게 주시면 감사하겠습니다.

## 2021.03.25

| 메모리    | 시간  | 코드 길이 |
| --------- | ----- | --------- |
| 28776 KB  | 64 ms | 252 B     |

```python
a, b, c = map(int, input().split())

if a == b and b == c:
    print(10000 + a * 1000)
elif a != b and b != c and c != a:
    print(max(a, b, c) * 100)
else:
    if a == b or a == c:
        print(1000 + a * 100)
    else:
        print(1000 + b * 100)
```

## 참고 답안

```python
# 풀이 1-1
# split을 사용하지 않고 input을 a, b, c에 각각 받는 법 같다.
# a, b, c는 숫자가 아닌 문자로 받았다.
*_, a, b, c = sorted(input())
# [1b, c][index]의 결괏값을 정한다.
    # a, b, c를 문자로 받았기 때문에 "1" + b의 결과는 1b이다.
    # 세 눈이 모두 다른 경우만 a < b < c가 성립해 index 값이 1이 된다.
# slice를 이용해 뒤에 붙일 0의 개수를 정한다.
    # 세 눈이 모두 같은 경우만 a < c가 성립하지 않아 그 값이 0이 된다.
# 경우에 따른 결과 도출은 아래의 설명을 참고한다.
print(["1" + b, c][a < b < c] + "000"[a < c :])

# 풀이 1-2
# a < b < c
a, b, c = sorted(map(int, input().split()))
# [c, b + 10, b * 10 + 100][index]의 결괏값을 정한다.
# index: [a, b, c].count(b) - 1 
    # [a, b, c]중 b와 같은 값의 개수를 구한 뒤
    # index는 0부터 시작해야 하므로 1을 빼준다.
# 경우에 따른 결과 도출은 아래의 설명을 참고한다.
print([c, b + 10, b * 10 + 100][[a, b, c].count(b) - 1] * 100)
```

### 아이디어 & 풀이

두 풀이 모두 주어진 값을 정렬해서 사용했다 (`a < b < c`).

* 주어진 값을 정렬하면 a, b, c는 다음과 같은 성질을 갖는다.
    * `c`는 최댓값이다
    * `b`는 중간에 있는 값이므로 같은 눈이 존재하는 경우 반드시 그 값 중 하나이다.
* 입력받은 값을 정렬했을 때 각 경우에 따른 결괏값은 다음과 같다.
    |경우|결괏값|
    |:---:|:---:|
    |같은 눈 없음|`c00`|
    |같은 눈 2개|`1b00`|
    |같은 눈 3개|`1b000`|

다른 풀이 1과 2 모두 리스트의 인덱스 표기법을 이용해서 풀었다.

* 풀이 1-1은 대소관계의 참(1), 거짓(0) 결과를 이용해서 인덱스를 결정했다. 리스트:
    |경우|`a < b < c`|`[1b, c]` 값|`a < c`|`"000"` 값|비고|
    |:---:|:---:|:---:|:---:|:---:|:---:|
    |같은 눈 없음|1|`c`|1|`"000"[1:]` → `"00"`|`"c" + "00"` → `c00`|
    |같은 눈 2개|0|`1b`|1|`"000"[1:]` → `"00"`|`"1b" + "00"` → `1b00`|
    |같은 눈 3개|0|`1b`|0|`"000"[0:]` → `"000"`|`"1b" + "000"` → `1b000`|
* 풀이 1-2는 가운데 있는 `b`의 개수를 이용해 인덱스를 결정했다.
    |경우|`[a, b, c]`|`.count(b)`|인덱스|값|비고|
    |:---:|:---:|:---:|:---:|:---:|:---:|
    |같은 눈 없음|`[a, b, c]`|1|0|`c`|`c * 100` → `c00`|
    |같은 눈 2개|`[a, b, b]`<br>`[b, b, c]`|2|1|`b + 10`|`(10 + b) * 100` → `1b00`|
    |같은 눈 3개|`[b, b, b]`|3|2|`b * 10 + 100`|`(100 + b * 10) * 100` → `1b000`|
* 이 외의 풀이도 구현 방식은 차이가 있지만, 핵심은 전체적으로 비슷했다.
