---
layout  : article
title   : Programmers_42746 가장 큰 수
summary : 
date    : 2023-04-14 17:52:46 +0900
updated : 2024-03-14 17:29:12 +0900
tag     : ps-js
toc     : true
public  : true
parent  : [[/programmers]]
latex   : false
---
* TOC
{:toc}

> 이 글은 프로그래머스의 [42746번](https://school.programmers.co.kr/learn/courses/30/lessons/42746) 문제를 자바스크립트(JavaScript)으로 풀이한 것을 모아놓은 글입니다.
>
> 일종의 연습 기록이며 제가 정답을 받은 코드와 참고할만한 다른 코드를 같이 기록합니다. 필요한 경우 코드에 대한 해설을 기록합니다만 코드는 통과했어도 해설은 틀릴 수 있기 때문에 가볍게 참고해주시길 부탁드립니다. 피드백은 편하신 방법으로 자유롭게 주시면 감사하겠습니다.

## 2023.04.14

| 테스트    | 통과 | 시간     | 메모리 |
| ---       | ---  | ---      | ---    |
| 테스트 1  | 통과 | 67.61ms  | 43.2MB |
| 테스트 2  | 통과 | 39.31ms  | 42.3MB |
| 테스트 3  | 통과 | 103.34ms | 44.8MB |
| 테스트 4  | 통과 | 2.85ms   | 36.4MB |
| 테스트 5  | 통과 | 61.89ms  | 44.7MB |
| 테스트 6  | 통과 | 57.47ms  | 43.9MB |
| 테스트 7  | 통과 | 0.09ms   | 33.5MB |
| 테스트 8  | 통과 | 0.06ms   | 33.5MB |
| 테스트 9  | 통과 | 0.06ms   | 33.4MB |
| 테스트 10 | 통과 | 0.11ms   | 33.4MB |
| 테스트 11 | 통과 | 0.06ms   | 33.6MB |
| 테스트 12 | 통과 | 0.05ms   | 33.5MB |
| 테스트 13 | 통과 | 0.05ms   | 33.4MB |
| 테스트 14 | 통과 | 0.06ms   | 33.5MB |
| 테스트 15 | 통과 | 0.05ms   | 33.6MB |

| 단계      | 시작 시각 | 끝난 시각 | 걸린 시간 |
| --------- | --------- | --------- | --------- |
| 문제 이해 | 17:54:34  | 17:55:08  |           |
| 풀이 생각 | 17:55:16  | 17:56:20  |           |
| 코딩      | 17:56:21  | 18:07:53  |           |
| 디버깅    | 22:32:07  | 22:40:00  |           |

```js
function solution(numbers) {
    const answer = numbers.sort((a, b) => {
        const A = `${a}${b}`;
        const B = `${b}${a}`;

        return B - A
    });

    if (answer[0] === 0) {
        return "0";
    }

    return answer.join("");
}
```

### 아이디어 & 풀이

* 더 큰 수를 만들 수 있는 수가 앞으로 오도록 `numbers`를 정렬한 뒤 `join` 해서 출력한다.
* 비교하는 두 수를 a, b라고 했을 때 `ab`와 `ba`를 비교해서 더 큰 경우를 찾으면 된다.
    * e.g, 6과 10을 비교했을 때 610이 106보다 큰 수이므로 6이 앞으로 와야 더 큰 수를 만들 수 있다.

### 디버그

* `numbers`가 여러 개의 0으로만 이루어진 배열일 경우 (e.g, `[0, 0, 0]`) 이를 `join`하면 0이 여러 개인 문자열(e.g, `"000"`)이 출력된다.
* 이를 방지하게 위해 `answer`의 첫 값이 0인 경우는 `"0"`만 출력하는 로직을 추가해주어야 한다.
* 0외에 다른 수가 포함되는 경우는 그 수가 가장 앞에 오므로 이 케이스를 고려해줄 필요가 없다.

### 피드백

* 만드는 수의 자리가 똑같으므로 `return B - A`를 반환해도 됐을 것 같다.
* `answer[0] === 0`일 때 `"0"`을 반환하는 로직을 삼항 연산자로 작성했으면 더 깔끔했을 것 같다.

## 참고 답안

```js
function solution(numbers) {
    const answer = numbers
        .map((num) => num + "")
        .sort((a, b) => (b + a) * 1 - (a + b) * 1)
        .join("");

    return answer[0] === "0" ? "0" : answer;
}
```

### 아이디어 & 풀이

* `sort` 로직을 다르게 작성했다.
    * `map`에서 빈 공백을 더해 모든 숫자를 문자열로 바꿔준 뒤
    * 두 수를 더해 합하고, 다시 1을 곱해 숫자로 바꾼 뒤 차를 계산했다.
