---
layout  : article
title   : Programmers_86491 최소직사각형
summary : 
date    : 2023-11-17 22:50:12 +0900
updated : 2024-03-14 17:32:40 +0900
tag     : ps-js
toc     : true
public  : true
parent  : [[Programmers-Index]]
latex   : false
---
* TOC
{:toc}

> 이 글은 프로그래머스의 [86491번](https://programmers.co.kr/learn/courses/30/lessons/86491) 문제를 JavaScript로 풀이한 것을 모아놓은 글입니다.
>
> 일종의 연습 기록이며 제가 정답을 받은 코드와 참고할만한 다른 코드를 같이 기록합니다. 필요한 경우 코드에 대한 해설을 기록합니다만 코드는 통과했어도 해설은 틀릴 수 있기 때문에 가볍게 참고해주시길 부탁드립니다. 피드백은 편하신 방법으로 자유롭게 주시면 감사하겠습니다.

## 2023.11.17

| 테스트    | 통과 | 시간   | 메모리 |
| --------- | ---- | ------ | ------ |
| 테스트 1  | 통과 | 0.07ms | 33.4MB |
| 테스트 2  | 통과 | 0.07ms | 33.4MB |
| 테스트 3  | 통과 | 0.08ms | 33.5MB |
| 테스트 4  | 통과 | 0.09ms | 33.6MB |
| 테스트 5  | 통과 | 0.17ms | 33.6MB |
| 테스트 6  | 통과 | 0.18ms | 33.5MB |
| 테스트 7  | 통과 | 0.19ms | 33.4MB |
| 테스트 8  | 통과 | 0.19ms | 33.6MB |
| 테스트 9  | 통과 | 0.21ms | 33.4MB |
| 테스트 10 | 통과 | 0.24ms | 33.6MB |
| 테스트 11 | 통과 | 0.28ms | 33.6MB |
| 테스트 12 | 통과 | 0.35ms | 33.7MB |
| 테스트 13 | 통과 | 0.69ms | 34MB   |
| 테스트 14 | 통과 | 1.78ms | 37.4MB |
| 테스트 15 | 통과 | 2.18ms | 37.8MB |
| 테스트 16 | 통과 | 3.30ms | 38.5MB |
| 테스트 17 | 통과 | 3.51ms | 39MB   |
| 테스트 18 | 통과 | 3.58ms | 39.2MB |
| 테스트 19 | 통과 | 3.65ms | 39MB   |
| 테스트 20 | 통과 | 3.73ms | 40MB   |

| 단계        | 시작 시각 | 끝난 시각 | 걸린 시간 |
| ----------- | --------- | --------- | --------- |
| 문제 이해   | 22:50:58  | 22:52:28  |           |
| 풀이 생각 1 | 23:20:53  | 23:21:47  |           |
| 코딩 1      | 23:21:50  | 23:23:24  |           |
| 풀이 생각 2 | 23:23:36  | 23:29:14  |           |
| 코딩 2      | 23:29:16  | 23:35:09  |           |

```js
function solution(sizes) {
    let wallet = [0, 0];

    sizes.forEach(([h, v]) => {
        const set1 = [Math.max(wallet[0], h), Math.max(wallet[1], v)];
        const set2 = [Math.max(wallet[0], v), Math.max(wallet[1], h)];

        wallet = set1[0] * set1[1] > set2[0] * set2[1] ? set2 : set1;
    });

    return wallet[0] * wallet[1];
}
```

### 아이디어 & 풀이

`sizes`를 순회하면서 명함 두 변의 길이 `h`, `v`와 현재 지갑의 크기인 `max` 두 변의 크기를 각각 비교해 더 큰 값으로 업데이트 한다.

* 주어진 `h`, `v`를 현재 지갑에 넣을 수 있는 방법은 두 가지이므로 두 조합을 만든 뒤 양 변의 곱이 작은 값을 선택한다.

### 피드백

* 참고 답안의 로직이 더 깔끔한 것 같다.

## 참고 답안

| 테스트    | 통과 | 시간   | 메모리 |
| --------- | ---- | ------ | ------ |
| 테스트 1  | 통과 | 0.08ms | 33.4MB |
| 테스트 2  | 통과 | 0.08ms | 33.4MB |
| 테스트 3  | 통과 | 0.09ms | 33.5MB |
| 테스트 4  | 통과 | 0.09ms | 33.4MB |
| 테스트 5  | 통과 | 0.08ms | 33.5MB |
| 테스트 6  | 통과 | 0.19ms | 33.4MB |
| 테스트 7  | 통과 | 0.21ms | 33.4MB |
| 테스트 8  | 통과 | 0.22ms | 33.6MB |
| 테스트 9  | 통과 | 0.20ms | 33.5MB |
| 테스트 10 | 통과 | 0.27ms | 33.5MB |
| 테스트 11 | 통과 | 0.32ms | 33.5MB |
| 테스트 12 | 통과 | 0.35ms | 33.6MB |
| 테스트 13 | 통과 | 0.79ms | 34MB   |
| 테스트 14 | 통과 | 1.31ms | 34.3MB |
| 테스트 15 | 통과 | 2.99ms | 37MB   |
| 테스트 16 | 통과 | 4.71ms | 38.1MB |
| 테스트 17 | 통과 | 5.59ms | 39.6MB |
| 테스트 18 | 통과 | 6.14ms | 40MB   |
| 테스트 19 | 통과 | 5.78ms | 40.1MB |
| 테스트 20 | 통과 | 5.98ms | 40.8MB |

```js
function solution(sizes) {
    const sorted = sizes.map(([w, h]) => (w < h ? [h, w] : [w, h]));

    let wallet = [0, 0];
    sorted.forEach(([w, h]) => {
        if (w > wallet[0]) wallet[0] = w;
        if (h > wallet[1]) wallet[1] = h;
    });
    return wallet[0] * wallet[1];
}
```

### 아이디어 & 풀이

* `sizes`의 각 원소를 왼쪽이 더 큰 값이 오도록 정렬한 뒤 긴 변은 긴 변끼리 작은 변은 작은 변끼리 비교하면서 값이 큰 경우에 업데이트 한다.
